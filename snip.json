{
  // https://snippet-generator.app/  [GOTO:] for generating snippet [NOTE:]
  // Place your snippets for javascript here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  //  "prefix": "log",
  //  "body": [
  //    "console.log('$1');",
  //    "$2"
  //  ],
  //  "description": "Log output to console"
  // }
  "memo": {
    "prefix": "2DMatrix",
    "body": [
      "const dp = [...Array(n+1)].map(() => Array(capacity+1).fill(-1))"
    ],
    "description": "memo"
  },
  "print2DMatrix": {
    "prefix": "print2DMatrix",
    "body": [
      "const print2DMatrix = (matrix) => {",
      "  const length = matrix[0].length -1",
      "  console.info('_____'.repeat(length))",
      "  for(let i = 0; i < matrix.length; i++) {",
      "    console.info('| ' +matrix[i].join(\" | \") + ' |')",
      "  }",
      "  console.info('-----'.repeat(length))",
      "}"
    ],
    "description": "print2DMatrix"
  },
  "print1DArray": {
    "prefix": "print1DArray",
    "body": [
      "function printList(lst){",
      "    output = \"[\"",
      "    var i = 0",
      "    for (i = 0; i < lst.length - 1; i++){",
      "        output += lst[i] + \", \"",
      "    }",
      "    output += lst[i] + \"]\"",
      "    return output",
      "}"
    ],
    "description": "print 1D Array as list"
  },
  "main": {
    "prefix": "main_driver",
    "body": [
      "// Driver code",
      "var main = function () {",
      "  const fn = ",
      "  const input = []",
      "  /**",
      "   *  Fill the time complexity for each function",
      "   */",
      "",
      "  for (var i = 0; i < input.length; i++) {",
      "      console.log(i + 1 + \".\\t Input array: \\t\", input[i]);",
      "      var result = fn(...input[i]);",
      "      console.log(\"\\t Result is \\t: \",result);",
      "      console.log(\"-\".repeat(100));",
      "  }",
      "}",
      "",
      "main();"
    ],
    "description": "main"
  },
  "iterate2DMatrix": {
    "prefix": "iterate2D",
    "body": [
      "  const rows = matrix.length",
      "  const columns = matrix[0].length",
      "",
      "  for(let r = 0 ; r < rows; r++) {",
      "    for(let c= 0; c< columns; c++) {",
      "      const element = matrix [r][c]",
      "    }",
      "  }"
    ],
    "description": "iterate2DMatrix"
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "const createGraphUndirected = (N, edges, isDirected = false) => {",
      "  const graph = {}",
      "  for (let e of edges) {",
      "    graph[e[0]] ? graph[e[0]].add(e[1]) : graph[e[0]] = new Set([e[1]])",
      "    if(!isDirected) {",
      "      graph[e[1]] ? graph[e[1]].add(e[0]) : graph[e[1]] = new Set([e[0]])",
      "    }",
      "  }",
      "  return graph",
      "}"
    ],
    "description": "create graph"
  },
  "create graph": {
    "prefix": "createGraph",
    "body": [
      "const createGraph = (N, edges, isDirected) => {",
      "  const graph = Array(N).fill().map(() => Array().fill([]))",
      "  for(const e of edges) {",
      "    graph[e[0]].push(e[1])",
      "    if(!isDirected){",
      "      graph[e[1]].push(e[0])",
      "    }",
      "  }",
      "  return graph",
      "}"
    ],
    "description": "create graph"
  }

}
