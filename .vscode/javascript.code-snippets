{
  // https://snippet-generator.app/  [GOTO:] for generating snippet [NOTE:]
  // Place your snippets for javascript here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  //  "prefix": "log",
  //  "body": [
  //    "console.log('$1');",
  //    "$2"
  //  ],
  //  "description": "Log output to console"
  // }
  "memo": {
    "prefix": "2DMatrix",
    "body": [
      "const dp = [...Array(n+1)].map(() => Array(capacity+1).fill(-1))"
    ],
    "description": "memo"
  },
  "print2DMatrix": {
    "prefix": "print2DMatrix",
    "body": [
      "const print2DMatrix = (matrix) => {",
      "  const length = matrix[0].length -1",
      "  console.info('_____'.repeat(length))",
      "  for(let i = 0; i < matrix.length; i++) {",
      "    console.info('| ' +matrix[i].join(\" | \") + ' |')",
      "  }",
      "  console.info('-----'.repeat(length))",
      "}"
    ],
    "description": "print2DMatrix"
  },
  "print1DArray": {
    "prefix": "print1DArray",
    "body": [
      "function printList(lst){",
      "    output = \"[\"",
      "    var i = 0",
      "    for (i = 0; i < lst.length - 1; i++){",
      "        output += lst[i] + \", \"",
      "    }",
      "    output += lst[i] + \"]\"",
      "    return output",
      "}"
    ],
    "description": "print 1D Array as list"
  },
  "main": {
  "prefix": "main_driver",
  "body": [
    "/*",
    "Problem link : https://leetcode.com/problems/",
    "------------------------------------------------------------------------------------",
    "Description: ",
    "",
    "------------------------------------------------------------------------------------",
    "Example:",
    "",
    "------------------------------------------------------------------------------------",
    "Input:",
    "",
    "------------------------------------------------------------------------------------",
    "Constraints:",
    "",
    "------------------------------------------------------------------------------------",
    "",
    "*/",
    "",
    "/**",
    " Intuition: ",
    " Time Complexity: ",
    " Space Complexity:",
    " Notes: ",
    " */",
    "var solution = function() {",
    "    ",
    "};",
    "",
    "// Driver code",
    " ",
    "",
    "var main = function () {",
    "  const fn = ",
    "  const input = []",
    "  /**",
    "   *  Fill the time complexity for each function",
    "   */",
    "",
    "  for (var i = 0; i < input.length; i++) {",
    "      console.log(i + 1 + \".\\t Input array: \\t\", input[i]);",
    "      var result = fn(input[i]);",
    "      console.log(\"\\t Result is \\t: \",result);",
    "      console.log(\"-\".repeat(100));",
    "  }",
    "}",
    "",
    "main();"
  ],
  "description": "main"
},
  "iterate2DMatrix": {
    "prefix": "iterate2D",
    "body": [
      "  const rows = matrix.length",
      "  const columns = matrix[0].length",
      "",
      "  for(let r = 0 ; r < rows; r++) {",
      "    for(let c= 0; c< columns; c++) {",
      "      const element = matrix [r][c]",
      "    }",
      "  }"
    ],
    "description": "iterate2DMatrix"
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "const createGraphUndirected = (N, edges, isDirected = false) => {",
      "  const graph = {}",
      "  for (let e of edges) {",
      "    graph[e[0]] ? graph[e[0]].add(e[1]) : graph[e[0]] = new Set([e[1]])",
      "    if(!isDirected) {",
      "      graph[e[1]] ? graph[e[1]].add(e[0]) : graph[e[1]] = new Set([e[0]])",
      "    }",
      "  }",
      "  return graph",
      "}"
    ],
    "description": "create graph"
  },
  "create graph": {
    "prefix": "createGraph",
    "body": [
      "const createGraph = (N, edges, isDirected) => {",
      "  const graph = Array(N).fill().map(() => Array().fill([]))",
      "  for(const e of edges) {",
      "    graph[e[0]].push(e[1])",
      "    if(!isDirected){",
      "      graph[e[1]].push(e[0])",
      "    }",
      "  }",
      "  return graph",
      "}"
    ],
    "description": "create graph"
  },
  "minHeap": {
  "prefix": "minHeap",
  "body": [
    "class PriorityQueue {",
    "  constructor(comparator= (a, b) => a <= b) {",
    "    this.heap = []",
    "    this.count = 0",
    "    this.comparator = comparator",
    "  }",
    "",
    "  size () {",
    "    return this.heap.length -1",
    "  }",
    "",
    "  push(element) {",
    "    /**",
    "     - push the element to the end of the array",
    "     */",
    "    const insertIndex = this.heap.push(element) -1",
    "    // need to heapify down only when ",
    "    if(this.heap.length > 1) {",
    "      this.heapifyUp(insertIndex)",
    "    }",
    "  }",
    "",
    "  buildHeap(elements = []) {",
    "    for(let elem of elements) {",
    "      this.push(elem)",
    "    }",
    "  }",
    "  pop() {",
    "    /**",
    "     - pop the top element",
    "     - assign the last element from the array to the rot node",
    "     - call heapifyDown on root node",
    "     */",
    "    const element = this.heap[0]",
    "    if (this.heap.length > 1) {",
    "      this.heap[0] = this.heap[this.heap.length -1] // assign the last element from the array to root node",
    "    }",
    "    this.heap.pop()",
    "    // call the heapify down",
    "    this.heapifyDown(0)",
    "    return element",
    "  }",
    "  heapifyUp(nodeIndex) {",
    "    /**",
    "      - check the heap condition using comparator : ie: min/max parent vs child",
    "      - true : do nothing",
    "      - false :",
    "        - find the min/max of the child node and swap it with parent node",
    "        - call heapifyUp(switched_child_node) ",
    "     */",
    "    // console.info(`heapifyUp: childIndex: ${nodeIndex}`)",
    "    if (nodeIndex == 0) return",
    "    const parentIndex = Math.floor((nodeIndex -1) / 2)",
    "    // if the heap condition fails ",
    "    if (this.comparator(this.heap[parentIndex] , this.heap[nodeIndex]) == false) {",
    "      // then : swap the node with the parent and heapify on the parent",
    "      [this.heap[parentIndex], this.heap[nodeIndex]] = [ this.heap[nodeIndex], this.heap[parentIndex]]",
    "      this.heapifyUp(parentIndex)",
    "    }",
    "    ",
    "  }",
    "  heapifyDown(nodeIndex) {",
    "    /**",
    "      check the parent node satisfies the heap property suing comparator",
    "      if true : do nothing",
    "      else :",
    "       swap the parent node with the child node ",
    "       call heapifyDown(swapped childNode)",
    "     */",
    "    const leftChild = (2 * nodeIndex) + 1",
    "    const rightChild = (2 * nodeIndex) + 2",
    "    const parent = this.heap[nodeIndex]",
    "    let swapIndex = nodeIndex",
    "    // check the condition that parent is min/max from the child",
    "",
    "    if(leftChild < this.heap.length && this.comparator(this.heap[leftChild], parent)) {",
    "      swapIndex = leftChild",
    "    }",
    "    if(rightChild < this.heap.length && this.comparator(this.heap[rightChild], this.heap[swapIndex])) {",
    "      // additionally check if right is still greater/smaller according to heap",
    "      // if (this.comparator(this.heap[rightChild], this.heap[leftChild])) {",
    "        swapIndex = rightChild",
    "      // }",
    "      ",
    "    }",
    "    // if heap condition is not valid ",
    "    // swap the parent and invalid condition child node",
    "    // console.info(`swapIndex: ${swapIndex} : value ${this.heap[swapIndex]}, nodeIndex: ${nodeIndex} : value ${this.heap[nodeIndex]}`)",
    "    if(swapIndex != nodeIndex) {",
    "      // swap the parent and child",
    "      [this.heap[nodeIndex], this.heap[swapIndex]] = [ this.heap[swapIndex], this.heap[nodeIndex]]",
    "      this.heapifyDown(swapIndex)",
    "    }",
    "  }",
    "  sort() {",
    "    const sorted = []",
    "    while(this.heap.length) {",
    "      sorted.push(this.pop())",
    "    }",
    "    return sorted",
    "  }",
    "}"
  ],
  "description": "minHeap"
  },
  "isObjectEq": {
  "prefix": "isEqual",
  "body": [
    "const isObjectEqual = (a, b) => {",
    "  let result = true",
    "  const lenA = Object.keys(a).length",
    "  const lenB = Object.keys(a).length",
    "  if(lenA === lenB) {",
    "    Object.keys(a).forEach((key) => {",
    "      // check if the key exist in both object and its value are equal",
    "      if(a[key] !== b[key]) result = false",
    "    })",
    "  } else {",
    "    result = false",
    "  }",
    "  return result",
    "}"
  ],
  "description": "isObjectEq"
}

}
